From 0818e8c4b51364ad07700d213adb3989f0f9b1aa Mon Sep 17 00:00:00 2001
From: Joshua Strobl <joshua@streambits.io>
Date: Thu, 19 Sep 2019 08:29:07 +0300
Subject: [PATCH 1/1] Implement AppMenu toggling.

In our previous GNOME Stack release, I opted to completely remove the AppMenu. This was done as there was clear indications at the time that it was planned to be deprecated or removed, given the respective functionality was being moved out of AppMenu across multiple GNOME applications and into the Headerbar menus. Unfortunately, either such deprecation hasn't come to fruition yet, there was mixed messaging by GNOME, or such plans are no longer moving forward.

As such, I've opted to implement a setting to enable the toggling on of AppMenu functionality. This is really only done to allow for Solus GNOME users to enable and utilize third-party extensions that otherwise leverage the AppMenu, otherwise I would just permanently remove the functionality given it provides no real user value otherwise (in my opinion).
---
 data/org.gnome.shell.gschema.xml.in |    7 +
 js/ui/panel.js                      | 1007 ++++++++++++++-------------
 js/ui/popupMenu.js                  |    6 +
 3 files changed, 533 insertions(+), 487 deletions(-)

diff --git a/data/org.gnome.shell.gschema.xml.in b/data/org.gnome.shell.gschema.xml.in
index 99221a7dd..a7742f180 100644
--- a/data/org.gnome.shell.gschema.xml.in
+++ b/data/org.gnome.shell.gschema.xml.in
@@ -101,6 +101,13 @@
         adapter is ever seen not to have devices associated to it.
       </description>
     </key>
+    <key name="show-app-menu" type="b">
+      <default>false</default>
+      <summary>Show AppMenu</summary>
+      <description>
+        Shows the AppMenu with the current window information. Must be enabled for use by third-party AppMenu extensions.
+      </description>
+    </key>
     <key name="introspect" type="b">
       <default>false</default>
       <summary>Enable introspection API</summary>
diff --git a/js/ui/panel.js b/js/ui/panel.js
index b5da45432..a45ca6c0e 100644
--- a/js/ui/panel.js
+++ b/js/ui/panel.js
@@ -16,6 +16,7 @@ const Main = imports.ui.main;
 
 var PANEL_ICON_SIZE = 16;
 var APP_MENU_ICON_MARGIN = 0;
+const SHOW_APP_MENU = 'show-app-menu';
 
 var BUTTON_DND_ACTIVATION_TIMEOUT = 250;
 
@@ -45,10 +46,12 @@ function _over(srcColor, dstColor) {
 }
 
 function _premultiply(color) {
-    return new Clutter.Color({ red: _norm(color.red * color.alpha),
-                               green: _norm(color.green * color.alpha),
-                               blue: _norm(color.blue * color.alpha),
-                               alpha: color.alpha });
+    return new Clutter.Color({
+        red: _norm(color.red * color.alpha),
+        green: _norm(color.green * color.alpha),
+        blue: _norm(color.blue * color.alpha),
+        alpha: color.alpha
+    });
 }
 
 function _unpremultiply(color) {
@@ -58,8 +61,10 @@ function _unpremultiply(color) {
     let red = Math.min((color.red * 255 + 127) / color.alpha, 255);
     let green = Math.min((color.green * 255 + 127) / color.alpha, 255);
     let blue = Math.min((color.blue * 255 + 127) / color.alpha, 255);
-    return new Clutter.Color({ red: red, green: green,
-                               blue: blue, alpha: color.alpha });
+    return new Clutter.Color({
+        red: red, green: green,
+        blue: blue, alpha: color.alpha
+    });
 }
 
 class AppMenu extends PopupMenu.PopupMenu {
@@ -98,11 +103,11 @@ class AppMenu extends PopupMenu.PopupMenu {
             Gio.DBus.get(Gio.BusType.SESSION, null, (o, res) => {
                 let bus = Gio.DBus.get_finish(res);
                 bus.call('org.gnome.Software',
-                         '/org/gnome/Software',
-                         'org.gtk.Actions', 'Activate',
-                         GLib.Variant.new('(sava{sv})',
-                                          ['details', [args], null]),
-                         null, 0, -1, null, null);
+                    '/org/gnome/Software',
+                    'org.gtk.Actions', 'Activate',
+                    GLib.Variant.new('(sava{sv})',
+                        ['details', [args], null]),
+                    null, 0, -1, null, null);
             });
         });
 
@@ -211,7 +216,7 @@ var AppMenuButton = GObject.registerClass({
 
         let textureCache = St.TextureCache.get_default();
         textureCache.connect('icon-theme-changed',
-                             this._onIconThemeChanged.bind(this));
+            this._onIconThemeChanged.bind(this));
 
         let iconEffect = new Clutter.DesaturateEffect();
         this._iconBox = new St.Bin({ style_class: 'app-menu-icon' });
@@ -223,8 +228,10 @@ var AppMenuButton = GObject.registerClass({
             iconEffect.enabled = themeNode.get_icon_style() == St.IconStyle.SYMBOLIC;
         });
 
-        this._label = new St.Label({ y_expand: true,
-                                     y_align: Clutter.ActorAlign.CENTER });
+        this._label = new St.Label({
+            y_expand: true,
+            y_align: Clutter.ActorAlign.CENTER
+        });
         this._container.add_actor(this._label);
         this._arrow = PopupMenu.arrowIcon(St.Side.BOTTOM);
         this._container.add_actor(this._arrow);
@@ -238,9 +245,9 @@ var AppMenuButton = GObject.registerClass({
         this._spinner = new Animation.Spinner(PANEL_ICON_SIZE, true);
         this._container.add_actor(this._spinner.actor);
 
-        let menu = new AppMenu(this);
-        this.setMenu(menu);
-        this._menuManager.addMenu(menu);
+        this._appmenu = new AppMenu(this);
+        this.setMenu(this._appmenu);
+        this._menuManager.addMenu(this._appmenu);
 
         let tracker = Shell.WindowTracker.get_default();
         let appSys = Shell.AppSystem.get_default();
@@ -252,6 +259,9 @@ var AppMenuButton = GObject.registerClass({
             global.window_manager.connect('switch-workspace', this._sync.bind(this));
 
         this._sync();
+
+        global.settings.connect(`changed::${SHOW_APP_MENU}`, () => this._updateVisibility()); // Connect to our show-app-menu setting
+        this._updateVisibility(); // Do our initial trigger for AppMenu visibility
     }
 
     fadeIn() {
@@ -349,6 +359,9 @@ var AppMenuButton = GObject.registerClass({
     }
 
     _sync() {
+        if (!global.settings.get_boolean(SHOW_APP_MENU))
+            return;
+
         let targetApp = this._findTargetApp();
 
         if (this._targetApp != targetApp) {
@@ -373,8 +386,8 @@ var AppMenuButton = GObject.registerClass({
             this.fadeOut();
 
         let isBusy = (this._targetApp != null &&
-                      (this._targetApp.get_state() == Shell.AppState.STARTING ||
-                       this._targetApp.get_busy()));
+            (this._targetApp.get_state() == Shell.AppState.STARTING ||
+                this._targetApp.get_busy()));
         if (isBusy)
             this.startAnimation();
         else
@@ -413,94 +426,108 @@ var AppMenuButton = GObject.registerClass({
 
         super._onDestroy();
     }
+
+    _updateVisibility() {
+        let show = global.settings.get_boolean(SHOW_APP_MENU); // Get the current value
+
+        if (show) { // If we should show it
+            this.show();
+        } else { // If we should hide it
+            this.hide();
+        }
+
+        this.emit('changed');
+    }
 });
 
 var ActivitiesButton = GObject.registerClass(
-class ActivitiesButton extends PanelMenu.Button {
-    _init() {
-        super._init(0.0, null, true);
-        this.accessible_role = Atk.Role.TOGGLE_BUTTON;
+    class ActivitiesButton extends PanelMenu.Button {
+        _init() {
+            super._init(0.0, null, true);
+            this.accessible_role = Atk.Role.TOGGLE_BUTTON;
+
+            this.name = 'panelActivities';
+
+            /* Translators: If there is no suitable word for "Activities"
+               in your language, you can use the word for "Overview". */
+            this._label = new St.Label({
+                text: _("Activities"),
+                y_align: Clutter.ActorAlign.CENTER
+            });
+            this.add_actor(this._label);
 
-        this.name = 'panelActivities';
+            this.label_actor = this._label;
 
-        /* Translators: If there is no suitable word for "Activities"
-           in your language, you can use the word for "Overview". */
-        this._label = new St.Label({ text: _("Activities"),
-                                     y_align: Clutter.ActorAlign.CENTER });
-        this.add_actor(this._label);
+            this.connect('captured-event', this._onCapturedEvent.bind(this));
+            this.connect_after('key-release-event', this._onKeyRelease.bind(this));
 
-        this.label_actor = this._label;
+            Main.overview.connect('showing', () => {
+                this.add_style_pseudo_class('overview');
+                this.add_accessible_state(Atk.StateType.CHECKED);
+            });
+            Main.overview.connect('hiding', () => {
+                this.remove_style_pseudo_class('overview');
+                this.remove_accessible_state(Atk.StateType.CHECKED);
+            });
 
-        this.connect('captured-event', this._onCapturedEvent.bind(this));
-        this.connect_after('key-release-event', this._onKeyRelease.bind(this));
+            this._xdndTimeOut = 0;
+        }
 
-        Main.overview.connect('showing', () => {
-            this.add_style_pseudo_class('overview');
-            this.add_accessible_state (Atk.StateType.CHECKED);
-        });
-        Main.overview.connect('hiding', () => {
-            this.remove_style_pseudo_class('overview');
-            this.remove_accessible_state (Atk.StateType.CHECKED);
-        });
+        handleDragOver(source, _actor, _x, _y, _time) {
+            if (source != Main.xdndHandler)
+                return DND.DragMotionResult.CONTINUE;
 
-        this._xdndTimeOut = 0;
-    }
+            if (this._xdndTimeOut != 0)
+                Mainloop.source_remove(this._xdndTimeOut);
+            this._xdndTimeOut = Mainloop.timeout_add(BUTTON_DND_ACTIVATION_TIMEOUT, () => {
+                this._xdndToggleOverview();
+            });
+            GLib.Source.set_name_by_id(this._xdndTimeOut, '[gnome-shell] this._xdndToggleOverview');
 
-    handleDragOver(source, _actor, _x, _y, _time) {
-        if (source != Main.xdndHandler)
             return DND.DragMotionResult.CONTINUE;
+        }
 
-        if (this._xdndTimeOut != 0)
-            Mainloop.source_remove(this._xdndTimeOut);
-        this._xdndTimeOut = Mainloop.timeout_add(BUTTON_DND_ACTIVATION_TIMEOUT, () => {
-            this._xdndToggleOverview();
-        });
-        GLib.Source.set_name_by_id(this._xdndTimeOut, '[gnome-shell] this._xdndToggleOverview');
-
-        return DND.DragMotionResult.CONTINUE;
-    }
-
-    _onCapturedEvent(actor, event) {
-        if (event.type() == Clutter.EventType.BUTTON_PRESS ||
-            event.type() == Clutter.EventType.TOUCH_BEGIN) {
-            if (!Main.overview.shouldToggleByCornerOrButton())
-                return Clutter.EVENT_STOP;
+        _onCapturedEvent(actor, event) {
+            if (event.type() == Clutter.EventType.BUTTON_PRESS ||
+                event.type() == Clutter.EventType.TOUCH_BEGIN) {
+                if (!Main.overview.shouldToggleByCornerOrButton())
+                    return Clutter.EVENT_STOP;
+            }
+            return Clutter.EVENT_PROPAGATE;
         }
-        return Clutter.EVENT_PROPAGATE;
-    }
 
-    _onEvent(actor, event) {
-        super._onEvent(actor, event);
+        _onEvent(actor, event) {
+            super._onEvent(actor, event);
 
-        if (event.type() == Clutter.EventType.TOUCH_END ||
-            event.type() == Clutter.EventType.BUTTON_RELEASE)
-            if (Main.overview.shouldToggleByCornerOrButton())
-                Main.overview.toggle();
+            if (event.type() == Clutter.EventType.TOUCH_END ||
+                event.type() == Clutter.EventType.BUTTON_RELEASE)
+                if (Main.overview.shouldToggleByCornerOrButton())
+                    Main.overview.toggle();
 
-        return Clutter.EVENT_PROPAGATE;
-    }
+            return Clutter.EVENT_PROPAGATE;
+        }
 
-    _onKeyRelease(actor, event) {
-        let symbol = event.get_key_symbol();
-        if (symbol == Clutter.KEY_Return || symbol == Clutter.KEY_space) {
-            if (Main.overview.shouldToggleByCornerOrButton())
-                Main.overview.toggle();
+        _onKeyRelease(actor, event) {
+            let symbol = event.get_key_symbol();
+            if (symbol == Clutter.KEY_Return || symbol == Clutter.KEY_space) {
+                if (Main.overview.shouldToggleByCornerOrButton())
+                    Main.overview.toggle();
+            }
+            return Clutter.EVENT_PROPAGATE;
         }
-        return Clutter.EVENT_PROPAGATE;
-    }
 
-    _xdndToggleOverview() {
-        let [x, y] = global.get_pointer();
-        let pickedActor = global.stage.get_actor_at_pos(Clutter.PickMode.REACTIVE, x, y);
+        _xdndToggleOverview() {
+            let [x, y] = global.get_pointer();
+            let pickedActor = global.stage.get_actor_at_pos(Clutter.PickMode.REACTIVE, x, y);
 
-        if (pickedActor == this && Main.overview.shouldToggleByCornerOrButton())
-            Main.overview.toggle();
+            if (pickedActor == this && Main.overview.shouldToggleByCornerOrButton())
+                Main.overview.toggle();
 
-        Mainloop.source_remove(this._xdndTimeOut);
-        this._xdndTimeOut = 0;
-        return GLib.SOURCE_REMOVE;
-    }
-});
+            Mainloop.source_remove(this._xdndTimeOut);
+            this._xdndTimeOut = 0;
+            return GLib.SOURCE_REMOVE;
+        }
+    });
 
 var PanelCorner = class {
     constructor(side) {
@@ -625,12 +652,12 @@ var PanelCorner = class {
         cr.moveTo(0, offsetY);
         if (this._side == St.Side.LEFT)
             cr.arc(cornerRadius,
-                   borderWidth + cornerRadius,
-                   cornerRadius, Math.PI, 3 * Math.PI / 2);
+                borderWidth + cornerRadius,
+                cornerRadius, Math.PI, 3 * Math.PI / 2);
         else
             cr.arc(0,
-                   borderWidth + cornerRadius,
-                   cornerRadius, 3 * Math.PI / 2, 2 * Math.PI);
+                borderWidth + cornerRadius,
+                cornerRadius, 3 * Math.PI / 2, 2 * Math.PI);
         cr.lineTo(cornerRadius, offsetY);
         cr.closePath();
 
@@ -667,106 +694,106 @@ var PanelCorner = class {
 };
 
 var AggregateLayout = GObject.registerClass(
-class AggregateLayout extends Clutter.BoxLayout {
-    _init(params = {}) {
-        params['orientation'] = Clutter.Orientation.VERTICAL;
-        super._init(params);
+    class AggregateLayout extends Clutter.BoxLayout {
+        _init(params = {}) {
+            params['orientation'] = Clutter.Orientation.VERTICAL;
+            super._init(params);
 
-        this._sizeChildren = [];
-    }
+            this._sizeChildren = [];
+        }
 
-    addSizeChild(actor) {
-        this._sizeChildren.push(actor);
-        this.layout_changed();
-    }
+        addSizeChild(actor) {
+            this._sizeChildren.push(actor);
+            this.layout_changed();
+        }
 
-    vfunc_get_preferred_width(container, forHeight) {
-        let themeNode = container.get_theme_node();
-        let minWidth = themeNode.get_min_width();
-        let natWidth = minWidth;
+        vfunc_get_preferred_width(container, forHeight) {
+            let themeNode = container.get_theme_node();
+            let minWidth = themeNode.get_min_width();
+            let natWidth = minWidth;
 
-        for (let i = 0; i < this._sizeChildren.length; i++) {
-            let child = this._sizeChildren[i];
-            let [childMin, childNat] = child.get_preferred_width(forHeight);
-            minWidth = Math.max(minWidth, childMin);
-            natWidth = Math.max(natWidth, childNat);
+            for (let i = 0; i < this._sizeChildren.length; i++) {
+                let child = this._sizeChildren[i];
+                let [childMin, childNat] = child.get_preferred_width(forHeight);
+                minWidth = Math.max(minWidth, childMin);
+                natWidth = Math.max(natWidth, childNat);
+            }
+            return [minWidth, natWidth];
         }
-        return [minWidth, natWidth];
-    }
-});
+    });
 
 var AggregateMenu = GObject.registerClass(
-class AggregateMenu extends PanelMenu.Button {
-    _init() {
-        super._init(0.0, C_("System menu in the top bar", "System"), false);
-        this.menu.actor.add_style_class_name('aggregate-menu');
+    class AggregateMenu extends PanelMenu.Button {
+        _init() {
+            super._init(0.0, C_("System menu in the top bar", "System"), false);
+            this.menu.actor.add_style_class_name('aggregate-menu');
 
-        let menuLayout = new AggregateLayout();
-        this.menu.box.set_layout_manager(menuLayout);
+            let menuLayout = new AggregateLayout();
+            this.menu.box.set_layout_manager(menuLayout);
 
-        this._indicators = new St.BoxLayout({ style_class: 'panel-status-indicators-box' });
-        this.add_child(this._indicators);
+            this._indicators = new St.BoxLayout({ style_class: 'panel-status-indicators-box' });
+            this.add_child(this._indicators);
 
-        if (Config.HAVE_NETWORKMANAGER) {
-            this._network = new imports.ui.status.network.NMApplet();
-        } else {
-            this._network = null;
-        }
-        if (Config.HAVE_BLUETOOTH) {
-            this._bluetooth = new imports.ui.status.bluetooth.Indicator();
-        } else {
-            this._bluetooth = null;
-        }
+            if (Config.HAVE_NETWORKMANAGER) {
+                this._network = new imports.ui.status.network.NMApplet();
+            } else {
+                this._network = null;
+            }
+            if (Config.HAVE_BLUETOOTH) {
+                this._bluetooth = new imports.ui.status.bluetooth.Indicator();
+            } else {
+                this._bluetooth = null;
+            }
 
-        this._remoteAccess = new imports.ui.status.remoteAccess.RemoteAccessApplet();
-        this._power = new imports.ui.status.power.Indicator();
-        this._rfkill = new imports.ui.status.rfkill.Indicator();
-        this._volume = new imports.ui.status.volume.Indicator();
-        this._brightness = new imports.ui.status.brightness.Indicator();
-        this._system = new imports.ui.status.system.Indicator();
-        this._screencast = new imports.ui.status.screencast.Indicator();
-        this._location = new imports.ui.status.location.Indicator();
-        this._nightLight = new imports.ui.status.nightLight.Indicator();
-        this._thunderbolt = new imports.ui.status.thunderbolt.Indicator();
-
-        this._indicators.add_child(this._thunderbolt.indicators);
-        this._indicators.add_child(this._screencast.indicators);
-        this._indicators.add_child(this._location.indicators);
-        this._indicators.add_child(this._nightLight.indicators);
-        if (this._network) {
-            this._indicators.add_child(this._network.indicators);
-        }
-        if (this._bluetooth) {
-            this._indicators.add_child(this._bluetooth.indicators);
-        }
-        this._indicators.add_child(this._remoteAccess.indicators);
-        this._indicators.add_child(this._rfkill.indicators);
-        this._indicators.add_child(this._volume.indicators);
-        this._indicators.add_child(this._power.indicators);
-        this._indicators.add_child(PopupMenu.arrowIcon(St.Side.BOTTOM));
-
-        this.menu.addMenuItem(this._volume.menu);
-        this.menu.addMenuItem(this._brightness.menu);
-        this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
-        if (this._network) {
-            this.menu.addMenuItem(this._network.menu);
-        }
-        if (this._bluetooth) {
-            this.menu.addMenuItem(this._bluetooth.menu);
+            this._remoteAccess = new imports.ui.status.remoteAccess.RemoteAccessApplet();
+            this._power = new imports.ui.status.power.Indicator();
+            this._rfkill = new imports.ui.status.rfkill.Indicator();
+            this._volume = new imports.ui.status.volume.Indicator();
+            this._brightness = new imports.ui.status.brightness.Indicator();
+            this._system = new imports.ui.status.system.Indicator();
+            this._screencast = new imports.ui.status.screencast.Indicator();
+            this._location = new imports.ui.status.location.Indicator();
+            this._nightLight = new imports.ui.status.nightLight.Indicator();
+            this._thunderbolt = new imports.ui.status.thunderbolt.Indicator();
+
+            this._indicators.add_child(this._thunderbolt.indicators);
+            this._indicators.add_child(this._screencast.indicators);
+            this._indicators.add_child(this._location.indicators);
+            this._indicators.add_child(this._nightLight.indicators);
+            if (this._network) {
+                this._indicators.add_child(this._network.indicators);
+            }
+            if (this._bluetooth) {
+                this._indicators.add_child(this._bluetooth.indicators);
+            }
+            this._indicators.add_child(this._remoteAccess.indicators);
+            this._indicators.add_child(this._rfkill.indicators);
+            this._indicators.add_child(this._volume.indicators);
+            this._indicators.add_child(this._power.indicators);
+            this._indicators.add_child(PopupMenu.arrowIcon(St.Side.BOTTOM));
+
+            this.menu.addMenuItem(this._volume.menu);
+            this.menu.addMenuItem(this._brightness.menu);
+            this.menu.addMenuItem(new PopupMenu.PopupSeparatorMenuItem());
+            if (this._network) {
+                this.menu.addMenuItem(this._network.menu);
+            }
+            if (this._bluetooth) {
+                this.menu.addMenuItem(this._bluetooth.menu);
+            }
+            this.menu.addMenuItem(this._remoteAccess.menu);
+            this.menu.addMenuItem(this._location.menu);
+            this.menu.addMenuItem(this._rfkill.menu);
+            this.menu.addMenuItem(this._power.menu);
+            this.menu.addMenuItem(this._nightLight.menu);
+            this.menu.addMenuItem(this._system.menu);
+
+            menuLayout.addSizeChild(this._location.menu.actor);
+            menuLayout.addSizeChild(this._rfkill.menu.actor);
+            menuLayout.addSizeChild(this._power.menu.actor);
+            menuLayout.addSizeChild(this._system.buttonGroup);
         }
-        this.menu.addMenuItem(this._remoteAccess.menu);
-        this.menu.addMenuItem(this._location.menu);
-        this.menu.addMenuItem(this._rfkill.menu);
-        this.menu.addMenuItem(this._power.menu);
-        this.menu.addMenuItem(this._nightLight.menu);
-        this.menu.addMenuItem(this._system.menu);
-
-        menuLayout.addSizeChild(this._location.menu.actor);
-        menuLayout.addSizeChild(this._rfkill.menu.actor);
-        menuLayout.addSizeChild(this._power.menu.actor);
-        menuLayout.addSizeChild(this._system.buttonGroup);
-    }
-});
+    });
 
 const PANEL_ITEM_IMPLEMENTATIONS = {
     'activities': ActivitiesButton,
@@ -779,385 +806,391 @@ const PANEL_ITEM_IMPLEMENTATIONS = {
 };
 
 var Panel = GObject.registerClass(
-class Panel extends St.Widget {
-    _init() {
-        super._init({ name: 'panel',
-                      reactive: true });
-
-        this.set_offscreen_redirect(Clutter.OffscreenRedirect.ALWAYS);
+    class Panel extends St.Widget {
+        _init() {
+            super._init({
+                name: 'panel',
+                reactive: true
+            });
 
-        this._sessionStyle = null;
+            this.set_offscreen_redirect(Clutter.OffscreenRedirect.ALWAYS);
 
-        this.statusArea = {};
+            this._sessionStyle = null;
 
-        this.menuManager = new PopupMenu.PopupMenuManager(this);
+            this.statusArea = {};
 
-        this._leftBox = new St.BoxLayout({ name: 'panelLeft' });
-        this.add_child(this._leftBox);
-        this._centerBox = new St.BoxLayout({ name: 'panelCenter' });
-        this.add_child(this._centerBox);
-        this._rightBox = new St.BoxLayout({ name: 'panelRight' });
-        this.add_child(this._rightBox);
+            this.menuManager = new PopupMenu.PopupMenuManager(this);
 
-        this._leftCorner = new PanelCorner(St.Side.LEFT);
-        this.add_child(this._leftCorner.actor);
+            this._leftBox = new St.BoxLayout({ name: 'panelLeft' });
+            this.add_child(this._leftBox);
+            this._centerBox = new St.BoxLayout({ name: 'panelCenter' });
+            this.add_child(this._centerBox);
+            this._rightBox = new St.BoxLayout({ name: 'panelRight' });
+            this.add_child(this._rightBox);
 
-        this._rightCorner = new PanelCorner(St.Side.RIGHT);
-        this.add_child(this._rightCorner.actor);
+            this._leftCorner = new PanelCorner(St.Side.LEFT);
+            this.add_child(this._leftCorner.actor);
 
-        this.connect('button-press-event', this._onButtonPress.bind(this));
-        this.connect('touch-event', this._onButtonPress.bind(this));
-        this.connect('key-press-event', this._onKeyPress.bind(this));
+            this._rightCorner = new PanelCorner(St.Side.RIGHT);
+            this.add_child(this._rightCorner.actor);
 
-        Main.overview.connect('showing', () => {
-            this.add_style_pseudo_class('overview');
-        });
-        Main.overview.connect('hiding', () => {
-            this.remove_style_pseudo_class('overview');
-        });
+            this.connect('button-press-event', this._onButtonPress.bind(this));
+            this.connect('touch-event', this._onButtonPress.bind(this));
+            this.connect('key-press-event', this._onKeyPress.bind(this));
 
-        Main.layoutManager.panelBox.add(this);
-        Main.ctrlAltTabManager.addGroup(this, _("Top Bar"), 'focus-top-bar-symbolic',
-                                        { sortGroup: CtrlAltTab.SortGroup.TOP });
+            Main.overview.connect('showing', () => {
+                this.add_style_pseudo_class('overview');
+            });
+            Main.overview.connect('hiding', () => {
+                this.remove_style_pseudo_class('overview');
+            });
 
-        Main.sessionMode.connect('updated', this._updatePanel.bind(this));
+            Main.layoutManager.panelBox.add(this);
+            Main.ctrlAltTabManager.addGroup(this, _("Top Bar"), 'focus-top-bar-symbolic',
+                { sortGroup: CtrlAltTab.SortGroup.TOP });
 
-        global.display.connect('workareas-changed', () => this.queue_relayout());
-        this._updatePanel();
-    }
+            Main.sessionMode.connect('updated', this._updatePanel.bind(this));
 
-    vfunc_get_preferred_width(_forHeight) {
-        let primaryMonitor = Main.layoutManager.primaryMonitor;
+            global.display.connect('workareas-changed', () => this.queue_relayout());
+            this._updatePanel();
+        }
 
-        if (primaryMonitor)
-            return [0, primaryMonitor.width];
+        vfunc_get_preferred_width(_forHeight) {
+            let primaryMonitor = Main.layoutManager.primaryMonitor;
 
-        return [0,  0];
-    }
+            if (primaryMonitor)
+                return [0, primaryMonitor.width];
 
-    vfunc_allocate(box, flags) {
-        this.set_allocation(box, flags);
-
-        let allocWidth = box.x2 - box.x1;
-        let allocHeight = box.y2 - box.y1;
+            return [0, 0];
+        }
 
-        let [, leftNaturalWidth] = this._leftBox.get_preferred_width(-1);
-        let [, centerNaturalWidth] = this._centerBox.get_preferred_width(-1);
-        let [, rightNaturalWidth] = this._rightBox.get_preferred_width(-1);
+        vfunc_allocate(box, flags) {
+            this.set_allocation(box, flags);
 
-        let sideWidth, centerWidth;
-        centerWidth = centerNaturalWidth;
+            let allocWidth = box.x2 - box.x1;
+            let allocHeight = box.y2 - box.y1;
 
-        // get workspace area and center date entry relative to it
-        let monitor = Main.layoutManager.findMonitorForActor(this);
-        let centerOffset = 0;
-        if (monitor) {
-            let workArea = Main.layoutManager.getWorkAreaForMonitor(monitor.index);
-            centerOffset = 2 * (workArea.x - monitor.x) + workArea.width - monitor.width;
-        }
+            let [, leftNaturalWidth] = this._leftBox.get_preferred_width(-1);
+            let [, centerNaturalWidth] = this._centerBox.get_preferred_width(-1);
+            let [, rightNaturalWidth] = this._rightBox.get_preferred_width(-1);
 
-        sideWidth = Math.max(0, (allocWidth - centerWidth + centerOffset) / 2);
+            let sideWidth, centerWidth;
+            centerWidth = centerNaturalWidth;
 
-        let childBox = new Clutter.ActorBox();
+            // get workspace area and center date entry relative to it
+            let monitor = Main.layoutManager.findMonitorForActor(this);
+            let centerOffset = 0;
+            if (monitor) {
+                let workArea = Main.layoutManager.getWorkAreaForMonitor(monitor.index);
+                centerOffset = 2 * (workArea.x - monitor.x) + workArea.width - monitor.width;
+            }
 
-        childBox.y1 = 0;
-        childBox.y2 = allocHeight;
-        if (this.get_text_direction() == Clutter.TextDirection.RTL) {
-            childBox.x1 = Math.max(allocWidth - Math.min(Math.floor(sideWidth),
-                                                         leftNaturalWidth),
-                                   0);
-            childBox.x2 = allocWidth;
-        } else {
-            childBox.x1 = 0;
-            childBox.x2 = Math.min(Math.floor(sideWidth),
-                                   leftNaturalWidth);
-        }
-        this._leftBox.allocate(childBox, flags);
+            sideWidth = Math.max(0, (allocWidth - centerWidth + centerOffset) / 2);
+
+            let childBox = new Clutter.ActorBox();
+
+            childBox.y1 = 0;
+            childBox.y2 = allocHeight;
+            if (this.get_text_direction() == Clutter.TextDirection.RTL) {
+                childBox.x1 = Math.max(allocWidth - Math.min(Math.floor(sideWidth),
+                    leftNaturalWidth),
+                    0);
+                childBox.x2 = allocWidth;
+            } else {
+                childBox.x1 = 0;
+                childBox.x2 = Math.min(Math.floor(sideWidth),
+                    leftNaturalWidth);
+            }
+            this._leftBox.allocate(childBox, flags);
+
+            childBox.x1 = Math.ceil(sideWidth);
+            childBox.y1 = 0;
+            childBox.x2 = childBox.x1 + centerWidth;
+            childBox.y2 = allocHeight;
+            this._centerBox.allocate(childBox, flags);
+
+            childBox.y1 = 0;
+            childBox.y2 = allocHeight;
+            if (this.get_text_direction() == Clutter.TextDirection.RTL) {
+                childBox.x1 = 0;
+                childBox.x2 = Math.min(Math.floor(sideWidth),
+                    rightNaturalWidth);
+            } else {
+                childBox.x1 = Math.max(allocWidth - Math.min(Math.floor(sideWidth),
+                    rightNaturalWidth),
+                    0);
+                childBox.x2 = allocWidth;
+            }
+            this._rightBox.allocate(childBox, flags);
 
-        childBox.x1 = Math.ceil(sideWidth);
-        childBox.y1 = 0;
-        childBox.x2 = childBox.x1 + centerWidth;
-        childBox.y2 = allocHeight;
-        this._centerBox.allocate(childBox, flags);
+            let cornerWidth, cornerHeight;
 
-        childBox.y1 = 0;
-        childBox.y2 = allocHeight;
-        if (this.get_text_direction() == Clutter.TextDirection.RTL) {
+            [, cornerWidth] = this._leftCorner.actor.get_preferred_width(-1);
+            [, cornerHeight] = this._leftCorner.actor.get_preferred_height(-1);
             childBox.x1 = 0;
-            childBox.x2 = Math.min(Math.floor(sideWidth),
-                                   rightNaturalWidth);
-        } else {
-            childBox.x1 = Math.max(allocWidth - Math.min(Math.floor(sideWidth),
-                                                         rightNaturalWidth),
-                                   0);
+            childBox.x2 = cornerWidth;
+            childBox.y1 = allocHeight;
+            childBox.y2 = allocHeight + cornerHeight;
+            this._leftCorner.actor.allocate(childBox, flags);
+
+            [, cornerWidth] = this._rightCorner.actor.get_preferred_width(-1);
+            [, cornerHeight] = this._rightCorner.actor.get_preferred_height(-1);
+            childBox.x1 = allocWidth - cornerWidth;
             childBox.x2 = allocWidth;
+            childBox.y1 = allocHeight;
+            childBox.y2 = allocHeight + cornerHeight;
+            this._rightCorner.actor.allocate(childBox, flags);
         }
-        this._rightBox.allocate(childBox, flags);
-
-        let cornerWidth, cornerHeight;
-
-        [, cornerWidth] = this._leftCorner.actor.get_preferred_width(-1);
-        [, cornerHeight] = this._leftCorner.actor.get_preferred_height(-1);
-        childBox.x1 = 0;
-        childBox.x2 = cornerWidth;
-        childBox.y1 = allocHeight;
-        childBox.y2 = allocHeight + cornerHeight;
-        this._leftCorner.actor.allocate(childBox, flags);
-
-        [, cornerWidth] = this._rightCorner.actor.get_preferred_width(-1);
-        [, cornerHeight] = this._rightCorner.actor.get_preferred_height(-1);
-        childBox.x1 = allocWidth - cornerWidth;
-        childBox.x2 = allocWidth;
-        childBox.y1 = allocHeight;
-        childBox.y2 = allocHeight + cornerHeight;
-        this._rightCorner.actor.allocate(childBox, flags);
-    }
 
-    _onButtonPress(actor, event) {
-        if (Main.modalCount > 0)
-            return Clutter.EVENT_PROPAGATE;
+        _onButtonPress(actor, event) {
+            if (Main.modalCount > 0)
+                return Clutter.EVENT_PROPAGATE;
 
-        if (event.get_source() != actor)
-            return Clutter.EVENT_PROPAGATE;
+            if (event.get_source() != actor)
+                return Clutter.EVENT_PROPAGATE;
 
-        let type = event.type();
-        let isPress = type == Clutter.EventType.BUTTON_PRESS;
-        if (!isPress && type != Clutter.EventType.TOUCH_BEGIN)
-            return Clutter.EVENT_PROPAGATE;
+            let type = event.type();
+            let isPress = type == Clutter.EventType.BUTTON_PRESS;
+            if (!isPress && type != Clutter.EventType.TOUCH_BEGIN)
+                return Clutter.EVENT_PROPAGATE;
 
-        let button = isPress ? event.get_button() : -1;
-        if (isPress && button != 1)
-            return Clutter.EVENT_PROPAGATE;
+            let button = isPress ? event.get_button() : -1;
+            if (isPress && button != 1)
+                return Clutter.EVENT_PROPAGATE;
 
-        let [stageX, stageY] = event.get_coords();
+            let [stageX, stageY] = event.get_coords();
 
-        let dragWindow = this._getDraggableWindowForPosition(stageX);
+            let dragWindow = this._getDraggableWindowForPosition(stageX);
 
-        if (!dragWindow)
-            return Clutter.EVENT_PROPAGATE;
-
-        global.display.begin_grab_op(dragWindow,
-                                     Meta.GrabOp.MOVING,
-                                     false, /* pointer grab */
-                                     true, /* frame action */
-                                     button,
-                                     event.get_state(),
-                                     event.get_time(),
-                                     stageX, stageY);
+            if (!dragWindow)
+                return Clutter.EVENT_PROPAGATE;
 
-        return Clutter.EVENT_STOP;
-    }
+            global.display.begin_grab_op(dragWindow,
+                Meta.GrabOp.MOVING,
+                false, /* pointer grab */
+                true, /* frame action */
+                button,
+                event.get_state(),
+                event.get_time(),
+                stageX, stageY);
 
-    _onKeyPress(actor, event) {
-        let symbol = event.get_key_symbol();
-        if (symbol == Clutter.KEY_Escape) {
-            global.display.focus_default_window(event.get_time());
             return Clutter.EVENT_STOP;
         }
 
-        return Clutter.EVENT_PROPAGATE;
-    }
+        _onKeyPress(actor, event) {
+            let symbol = event.get_key_symbol();
+            if (symbol == Clutter.KEY_Escape) {
+                global.display.focus_default_window(event.get_time());
+                return Clutter.EVENT_STOP;
+            }
 
-    _toggleMenu(indicator) {
-        if (!indicator || !indicator.container.visible)
-            return; // menu not supported by current session mode
+            return Clutter.EVENT_PROPAGATE;
+        }
 
-        let menu = indicator.menu;
-        if (!indicator.reactive)
-            return;
+        _toggleMenu(indicator) {
+            if (!indicator || !indicator.container.visible)
+                return; // menu not supported by current session mode
 
-        menu.toggle();
-        if (menu.isOpen)
-            menu.actor.navigate_focus(null, St.DirectionType.TAB_FORWARD, false);
-    }
+            let menu = indicator.menu;
+            if (!indicator.reactive)
+                return;
 
-    toggleAppMenu() {
-        this._toggleMenu(this.statusArea.appMenu);
-    }
+            menu.toggle();
+            if (menu.isOpen)
+                menu.actor.navigate_focus(null, St.DirectionType.TAB_FORWARD, false);
+        }
 
-    toggleCalendar() {
-        this._toggleMenu(this.statusArea.dateMenu);
-    }
+        toggleAppMenu() {
+            let show = global.settings.get_boolean(SHOW_APP_MENU); // Get the current value
 
-    closeCalendar() {
-        let indicator = this.statusArea.dateMenu;
-        if (!indicator) // calendar not supported by current session mode
-            return;
+            if (show) { // If we should show it
+                this._toggleMenu(this.statusArea.appMenu); // Allow toggling
+            }
+        }
 
-        let menu = indicator.menu;
-        if (!indicator.reactive)
-            return;
+        toggleCalendar() {
+            this._toggleMenu(this.statusArea.dateMenu);
+        }
 
-        menu.close();
-    }
+        closeCalendar() {
+            let indicator = this.statusArea.dateMenu;
+            if (!indicator) // calendar not supported by current session mode
+                return;
 
-    set boxOpacity(value) {
-        let isReactive = value > 0;
+            let menu = indicator.menu;
+            if (!indicator.reactive)
+                return;
 
-        this._leftBox.opacity = value;
-        this._leftBox.reactive = isReactive;
-        this._centerBox.opacity = value;
-        this._centerBox.reactive = isReactive;
-        this._rightBox.opacity = value;
-        this._rightBox.reactive = isReactive;
-    }
+            menu.close();
+        }
 
-    get boxOpacity() {
-        return this._leftBox.opacity;
-    }
+        set boxOpacity(value) {
+            let isReactive = value > 0;
 
-    _updatePanel() {
-        let panel = Main.sessionMode.panel;
-        this._hideIndicators();
-        this._updateBox(panel.left, this._leftBox);
-        this._updateBox(panel.center, this._centerBox);
-        this._updateBox(panel.right, this._rightBox);
-
-        if (panel.left.includes('dateMenu'))
-            Main.messageTray.bannerAlignment = Clutter.ActorAlign.START;
-        else if (panel.right.includes('dateMenu'))
-            Main.messageTray.bannerAlignment = Clutter.ActorAlign.END;
-        // Default to center if there is no dateMenu
-        else
-            Main.messageTray.bannerAlignment = Clutter.ActorAlign.CENTER;
+            this._leftBox.opacity = value;
+            this._leftBox.reactive = isReactive;
+            this._centerBox.opacity = value;
+            this._centerBox.reactive = isReactive;
+            this._rightBox.opacity = value;
+            this._rightBox.reactive = isReactive;
+        }
 
-        if (this._sessionStyle)
-            this._removeStyleClassName(this._sessionStyle);
+        get boxOpacity() {
+            return this._leftBox.opacity;
+        }
 
-        this._sessionStyle = Main.sessionMode.panelStyle;
-        if (this._sessionStyle)
-            this._addStyleClassName(this._sessionStyle);
+        _updatePanel() {
+            let panel = Main.sessionMode.panel;
+            this._hideIndicators();
+            this._updateBox(panel.left, this._leftBox);
+            this._updateBox(panel.center, this._centerBox);
+            this._updateBox(panel.right, this._rightBox);
+
+            if (panel.left.includes('dateMenu'))
+                Main.messageTray.bannerAlignment = Clutter.ActorAlign.START;
+            else if (panel.right.includes('dateMenu'))
+                Main.messageTray.bannerAlignment = Clutter.ActorAlign.END;
+            // Default to center if there is no dateMenu
+            else
+                Main.messageTray.bannerAlignment = Clutter.ActorAlign.CENTER;
+
+            if (this._sessionStyle)
+                this._removeStyleClassName(this._sessionStyle);
+
+            this._sessionStyle = Main.sessionMode.panelStyle;
+            if (this._sessionStyle)
+                this._addStyleClassName(this._sessionStyle);
+
+            if (this.get_text_direction() == Clutter.TextDirection.RTL) {
+                this._leftCorner.setStyleParent(this._rightBox);
+                this._rightCorner.setStyleParent(this._leftBox);
+            } else {
+                this._leftCorner.setStyleParent(this._leftBox);
+                this._rightCorner.setStyleParent(this._rightBox);
+            }
+        }
 
-        if (this.get_text_direction() == Clutter.TextDirection.RTL) {
-            this._leftCorner.setStyleParent(this._rightBox);
-            this._rightCorner.setStyleParent(this._leftBox);
-        } else {
-            this._leftCorner.setStyleParent(this._leftBox);
-            this._rightCorner.setStyleParent(this._rightBox);
+        _hideIndicators() {
+            for (let role in PANEL_ITEM_IMPLEMENTATIONS) {
+                let indicator = this.statusArea[role];
+                if (!indicator)
+                    continue;
+                indicator.container.hide();
+            }
         }
-    }
 
-    _hideIndicators() {
-        for (let role in PANEL_ITEM_IMPLEMENTATIONS) {
+        _ensureIndicator(role) {
             let indicator = this.statusArea[role];
-            if (!indicator)
-                continue;
-            indicator.container.hide();
+            if (!indicator) {
+                let constructor = PANEL_ITEM_IMPLEMENTATIONS[role];
+                if (!constructor) {
+                    // This icon is not implemented (this is a bug)
+                    return null;
+                }
+                indicator = new constructor(this);
+                this.statusArea[role] = indicator;
+            }
+            return indicator;
         }
-    }
 
-    _ensureIndicator(role) {
-        let indicator = this.statusArea[role];
-        if (!indicator) {
-            let constructor = PANEL_ITEM_IMPLEMENTATIONS[role];
-            if (!constructor) {
-                // This icon is not implemented (this is a bug)
-                return null;
+        _updateBox(elements, box) {
+            let nChildren = box.get_n_children();
+
+            for (let i = 0; i < elements.length; i++) {
+                let role = elements[i];
+                let indicator = this._ensureIndicator(role);
+                if (indicator == null)
+                    continue;
+
+                this._addToPanelBox(role, indicator, i + nChildren, box);
             }
-            indicator = new constructor(this);
-            this.statusArea[role] = indicator;
         }
-        return indicator;
-    }
 
-    _updateBox(elements, box) {
-        let nChildren = box.get_n_children();
+        _addToPanelBox(role, indicator, position, box) {
+            let container = indicator.container;
+            container.show();
 
-        for (let i = 0; i < elements.length; i++) {
-            let role = elements[i];
-            let indicator = this._ensureIndicator(role);
-            if (indicator == null)
-                continue;
+            let parent = container.get_parent();
+            if (parent)
+                parent.remove_actor(container);
 
-            this._addToPanelBox(role, indicator, i + nChildren, box);
-        }
-    }
 
-    _addToPanelBox(role, indicator, position, box) {
-        let container = indicator.container;
-        container.show();
+            box.insert_child_at_index(container, position);
+            if (indicator.menu)
+                this.menuManager.addMenu(indicator.menu);
+            this.statusArea[role] = indicator;
+            let destroyId = indicator.connect('destroy', emitter => {
+                delete this.statusArea[role];
+                emitter.disconnect(destroyId);
+            });
+            indicator.connect('menu-set', this._onMenuSet.bind(this));
+            this._onMenuSet(indicator);
+        }
 
-        let parent = container.get_parent();
-        if (parent)
-            parent.remove_actor(container);
+        addToStatusArea(role, indicator, position, box) {
+            if (this.statusArea[role])
+                throw new Error(`Extension point conflict: there is already a status indicator for role ${role}`);
 
+            if (!(indicator instanceof PanelMenu.Button))
+                throw new TypeError('Status indicator must be an instance of PanelMenu.Button');
 
-        box.insert_child_at_index(container, position);
-        if (indicator.menu)
-            this.menuManager.addMenu(indicator.menu);
-        this.statusArea[role] = indicator;
-        let destroyId = indicator.connect('destroy', emitter => {
-            delete this.statusArea[role];
-            emitter.disconnect(destroyId);
-        });
-        indicator.connect('menu-set', this._onMenuSet.bind(this));
-        this._onMenuSet(indicator);
-    }
+            position = position || 0;
+            let boxes = {
+                left: this._leftBox,
+                center: this._centerBox,
+                right: this._rightBox
+            };
+            let boxContainer = boxes[box] || this._rightBox;
+            this.statusArea[role] = indicator;
+            this._addToPanelBox(role, indicator, position, boxContainer);
+            return indicator;
+        }
 
-    addToStatusArea(role, indicator, position, box) {
-        if (this.statusArea[role])
-            throw new Error(`Extension point conflict: there is already a status indicator for role ${role}`);
-
-        if (!(indicator instanceof PanelMenu.Button))
-            throw new TypeError('Status indicator must be an instance of PanelMenu.Button');
-
-        position = position || 0;
-        let boxes = {
-            left: this._leftBox,
-            center: this._centerBox,
-            right: this._rightBox
-        };
-        let boxContainer = boxes[box] || this._rightBox;
-        this.statusArea[role] = indicator;
-        this._addToPanelBox(role, indicator, position, boxContainer);
-        return indicator;
-    }
+        _addStyleClassName(className) {
+            this.add_style_class_name(className);
+            this._rightCorner.actor.add_style_class_name(className);
+            this._leftCorner.actor.add_style_class_name(className);
+        }
 
-    _addStyleClassName(className) {
-        this.add_style_class_name(className);
-        this._rightCorner.actor.add_style_class_name(className);
-        this._leftCorner.actor.add_style_class_name(className);
-    }
+        _removeStyleClassName(className) {
+            this.remove_style_class_name(className);
+            this._rightCorner.actor.remove_style_class_name(className);
+            this._leftCorner.actor.remove_style_class_name(className);
+        }
 
-    _removeStyleClassName(className) {
-        this.remove_style_class_name(className);
-        this._rightCorner.actor.remove_style_class_name(className);
-        this._leftCorner.actor.remove_style_class_name(className);
-    }
+        _onMenuSet(indicator) {
+            if (!indicator.menu || indicator.menu._openChangedId)
+                return;
 
-    _onMenuSet(indicator) {
-        if (!indicator.menu || indicator.menu._openChangedId)
-            return;
+            indicator.menu._openChangedId = indicator.menu.connect('open-state-changed',
+                (menu, isOpen) => {
+                    let boxAlignment;
+                    if (this._leftBox.contains(indicator.container))
+                        boxAlignment = Clutter.ActorAlign.START;
+                    else if (this._centerBox.contains(indicator.container))
+                        boxAlignment = Clutter.ActorAlign.CENTER;
+                    else if (this._rightBox.contains(indicator.container))
+                        boxAlignment = Clutter.ActorAlign.END;
+
+                    if (boxAlignment == Main.messageTray.bannerAlignment)
+                        Main.messageTray.bannerBlocked = isOpen;
+                });
+        }
 
-        indicator.menu._openChangedId = indicator.menu.connect('open-state-changed',
-            (menu, isOpen) => {
-                let boxAlignment;
-                if (this._leftBox.contains(indicator.container))
-                    boxAlignment = Clutter.ActorAlign.START;
-                else if (this._centerBox.contains(indicator.container))
-                    boxAlignment = Clutter.ActorAlign.CENTER;
-                else if (this._rightBox.contains(indicator.container))
-                    boxAlignment = Clutter.ActorAlign.END;
-
-                if (boxAlignment == Main.messageTray.bannerAlignment)
-                    Main.messageTray.bannerBlocked = isOpen;
+        _getDraggableWindowForPosition(stageX) {
+            let workspaceManager = global.workspace_manager;
+            let workspace = workspaceManager.get_active_workspace();
+            let allWindowsByStacking = global.display.sort_windows_by_stacking(
+                workspace.list_windows()
+            ).reverse();
+
+            return allWindowsByStacking.find(metaWindow => {
+                let rect = metaWindow.get_frame_rect();
+                return metaWindow.is_on_primary_monitor() &&
+                    metaWindow.showing_on_its_workspace() &&
+                    metaWindow.get_window_type() != Meta.WindowType.DESKTOP &&
+                    metaWindow.maximized_vertically &&
+                    stageX > rect.x && stageX < rect.x + rect.width;
             });
-    }
-
-    _getDraggableWindowForPosition(stageX) {
-        let workspaceManager = global.workspace_manager;
-        let workspace = workspaceManager.get_active_workspace();
-        let allWindowsByStacking = global.display.sort_windows_by_stacking(
-            workspace.list_windows()
-        ).reverse();
-
-        return allWindowsByStacking.find(metaWindow => {
-            let rect = metaWindow.get_frame_rect();
-            return metaWindow.is_on_primary_monitor() &&
-                   metaWindow.showing_on_its_workspace() &&
-                   metaWindow.get_window_type() != Meta.WindowType.DESKTOP &&
-                   metaWindow.maximized_vertically &&
-                   stageX > rect.x && stageX < rect.x + rect.width;
-        });
-    }
-});
+        }
+    });
diff --git a/js/ui/popupMenu.js b/js/ui/popupMenu.js
index 1943b269f..06640c126 100644
--- a/js/ui/popupMenu.js
+++ b/js/ui/popupMenu.js
@@ -1259,6 +1259,12 @@ var PopupMenuManager = class {
     }
 
     removeMenu(menu) {
+        if (menu == undefined)
+            return;
+
+        if (this.activeMenu == undefined)
+            return;
+
         if (menu == this.activeMenu)
             this._closeMenu(false, menu);
 
-- 
2.23.0

